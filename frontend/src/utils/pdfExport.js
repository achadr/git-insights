import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

/**
 * Generate a professional PDF report from analysis data
 * @param {Object} analysisData - The analysis data object
 * @param {string} repoUrl - The repository URL
 * @returns {Promise<void>}
 */
export async function generatePDFReport(analysisData, repoUrl) {
  try {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    let yPosition = 20;

    // Extract repo name from URL
    const repoName = extractRepoName(repoUrl);
    const timestamp = new Date(analysisData.summary.timestamp).toLocaleDateString();
    const totalIssues = analysisData.files?.reduce((sum, file) => sum + (file.issues?.length || 0), 0) || 0;

    // ========== COVER PAGE ==========
    addCoverPage(doc, repoName, analysisData.summary.overallQuality, timestamp, pageWidth, pageHeight);

    // ========== SUMMARY PAGE ==========
    doc.addPage();
    yPosition = 20;
    yPosition = addSummaryPage(doc, analysisData, totalIssues, pageWidth, yPosition);

    // ========== FILES OVERVIEW TABLE ==========
    doc.addPage();
    yPosition = 20;
    yPosition = addFilesOverviewTable(doc, analysisData.files, pageWidth, yPosition);

    // ========== DETAILED FILE ANALYSIS ==========
    addDetailedFileAnalysis(doc, analysisData.files, pageWidth, pageHeight);

    // Add page numbers to all pages
    addPageNumbers(doc);

    // Save the PDF
    const fileName = `GitInsights_Report_${sanitizeFileName(repoName)}_${timestamp.replace(/\//g, '-')}.pdf`;
    doc.save(fileName);

    return { success: true, fileName };
  } catch (error) {
    console.error('Error generating PDF:', error);
    throw new Error('Failed to generate PDF report: ' + error.message);
  }
}

/**
 * Add cover page to the PDF
 */
function addCoverPage(doc, repoName, overallQuality, timestamp, pageWidth, pageHeight) {
  // Background color for header
  doc.setFillColor(37, 99, 235); // Blue-600
  doc.rect(0, 0, pageWidth, 80, 'F');

  // GitInsights Logo/Title
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(36);
  doc.setFont('helvetica', 'bold');
  doc.text('GitInsights', pageWidth / 2, 35, { align: 'center' });

  doc.setFontSize(14);
  doc.setFont('helvetica', 'normal');
  doc.text('Code Quality Analysis Report', pageWidth / 2, 50, { align: 'center' });

  // Reset text color
  doc.setTextColor(0, 0, 0);

  // Repository Information
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.text('Repository:', 20, 110);

  doc.setFontSize(16);
  doc.setFont('helvetica', 'normal');
  doc.text(repoName, 20, 125);

  // Analysis Date
  doc.setFontSize(12);
  doc.setTextColor(100, 100, 100);
  doc.text(`Analysis Date: ${timestamp}`, 20, 145);

  // Overall Quality Score - Large Visual
  const scoreColor = getScoreColor(overallQuality);
  const scoreY = 170;

  doc.setFontSize(14);
  doc.setTextColor(0, 0, 0);
  doc.setFont('helvetica', 'bold');
  doc.text('Overall Quality Score', pageWidth / 2, scoreY, { align: 'center' });

  // Score circle background
  doc.setFillColor(...scoreColor);
  doc.circle(pageWidth / 2, scoreY + 35, 30, 'F');

  // Score text
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(48);
  doc.setFont('helvetica', 'bold');
  doc.text(String(overallQuality), pageWidth / 2, scoreY + 42, { align: 'center' });

  // Score label
  doc.setTextColor(0, 0, 0);
  doc.setFontSize(12);
  doc.setFont('helvetica', 'normal');
  doc.text(getScoreLabel(overallQuality), pageWidth / 2, scoreY + 60, { align: 'center' });

  // Footer text
  doc.setFontSize(10);
  doc.setTextColor(150, 150, 150);
  doc.text('Generated by GitInsights - AI-Powered Code Analysis', pageWidth / 2, pageHeight - 20, { align: 'center' });
}

/**
 * Add summary page with statistics
 */
function addSummaryPage(doc, analysisData, totalIssues, pageWidth, startY) {
  let yPosition = startY;

  // Page Title
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text('Analysis Summary', 20, yPosition);
  yPosition += 15;

  // Summary Statistics Cards
  const stats = [
    { label: 'Files Analyzed', value: analysisData.summary.filesAnalyzed, color: [59, 130, 246] },
    { label: 'Total Issues', value: totalIssues, color: [239, 68, 68] },
    { label: 'Average Score', value: analysisData.summary.overallQuality, color: [147, 51, 234] },
  ];

  const cardWidth = 55;
  const cardHeight = 35;
  const cardSpacing = 10;
  const startX = 20;

  stats.forEach((stat, index) => {
    const x = startX + (cardWidth + cardSpacing) * index;

    // Card background
    doc.setFillColor(...stat.color, 0.1);
    doc.roundedRect(x, yPosition, cardWidth, cardHeight, 3, 3, 'F');

    // Border
    doc.setDrawColor(...stat.color);
    doc.setLineWidth(0.5);
    doc.roundedRect(x, yPosition, cardWidth, cardHeight, 3, 3, 'S');

    // Label
    doc.setFontSize(10);
    doc.setTextColor(100, 100, 100);
    doc.setFont('helvetica', 'normal');
    doc.text(stat.label, x + cardWidth / 2, yPosition + 12, { align: 'center' });

    // Value
    doc.setFontSize(24);
    doc.setTextColor(...stat.color);
    doc.setFont('helvetica', 'bold');
    doc.text(String(stat.value), x + cardWidth / 2, yPosition + 28, { align: 'center' });
  });

  yPosition += cardHeight + 20;

  // Quality Distribution Bar
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text('Quality Distribution', 20, yPosition);
  yPosition += 10;

  // Calculate distribution
  const distribution = calculateQualityDistribution(analysisData.files);
  const barWidth = pageWidth - 40;
  const barHeight = 30;
  const barX = 20;

  // Draw stacked bar
  let currentX = barX;
  const categories = [
    { key: 'excellent', label: 'Excellent (80-100)', color: [34, 197, 94] },
    { key: 'good', label: 'Good (60-79)', color: [59, 130, 246] },
    { key: 'fair', label: 'Fair (40-59)', color: [234, 179, 8] },
    { key: 'poor', label: 'Poor (0-39)', color: [239, 68, 68] },
  ];

  categories.forEach(category => {
    const segmentWidth = (distribution[category.key] / analysisData.files.length) * barWidth;
    if (segmentWidth > 0) {
      doc.setFillColor(...category.color);
      doc.rect(currentX, yPosition, segmentWidth, barHeight, 'F');
      currentX += segmentWidth;
    }
  });

  // Draw border
  doc.setDrawColor(200, 200, 200);
  doc.setLineWidth(1);
  doc.rect(barX, yPosition, barWidth, barHeight, 'S');

  yPosition += barHeight + 15;

  // Legend
  doc.setFontSize(9);
  categories.forEach((category, index) => {
    const legendX = 20 + (index * 45);

    // Color box
    doc.setFillColor(...category.color);
    doc.rect(legendX, yPosition, 4, 4, 'F');

    // Label
    doc.setTextColor(0, 0, 0);
    doc.setFont('helvetica', 'normal');
    doc.text(`${category.label}: ${distribution[category.key]}`, legendX + 6, yPosition + 3);
  });

  yPosition += 15;

  // Key Insights Section
  yPosition += 10;
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('Key Insights', 20, yPosition);
  yPosition += 10;

  const insights = generateKeyInsights(analysisData, distribution);
  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(60, 60, 60);

  insights.forEach(insight => {
    const lines = doc.splitTextToSize(`â€¢ ${insight}`, pageWidth - 50);
    lines.forEach(line => {
      doc.text(line, 25, yPosition);
      yPosition += 6;
    });
    yPosition += 2;
  });

  return yPosition;
}

/**
 * Add files overview table
 */
function addFilesOverviewTable(doc, files, pageWidth, startY) {
  let yPosition = startY;

  // Page Title
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text('Files Overview', 20, yPosition);
  yPosition += 10;

  // Prepare table data
  const tableData = files.map(file => [
    file.file,
    String(file.score),
    String(file.issues?.length || 0),
    String(file.recommendations?.length || 0),
    getScoreLabel(file.score)
  ]);

  // Generate table
  autoTable(doc, {
    startY: yPosition,
    head: [['File Path', 'Score', 'Issues', 'Recommendations', 'Rating']],
    body: tableData,
    theme: 'striped',
    headStyles: {
      fillColor: [37, 99, 235],
      textColor: [255, 255, 255],
      fontStyle: 'bold',
      fontSize: 10,
    },
    bodyStyles: {
      fontSize: 9,
      textColor: [0, 0, 0],
    },
    columnStyles: {
      0: { cellWidth: 70 },
      1: { cellWidth: 20, halign: 'center' },
      2: { cellWidth: 20, halign: 'center' },
      3: { cellWidth: 30, halign: 'center' },
      4: { cellWidth: 30, halign: 'center' },
    },
    didDrawCell: (data) => {
      // Color-code the score column
      if (data.column.index === 1 && data.section === 'body') {
        const score = parseInt(tableData[data.row.index][1]);
        const color = getScoreColor(score);
        doc.setFillColor(...color, 0.2);
        doc.rect(data.cell.x, data.cell.y, data.cell.width, data.cell.height, 'F');

        // Redraw text on top
        doc.setTextColor(0, 0, 0);
        doc.setFontSize(9);
        doc.text(String(score), data.cell.x + data.cell.width / 2, data.cell.y + data.cell.height / 2 + 2, { align: 'center' });
      }
    },
    margin: { left: 20, right: 20 },
  });

  return doc.lastAutoTable.finalY + 10;
}

/**
 * Add detailed file analysis
 */
function addDetailedFileAnalysis(doc, files, pageWidth, pageHeight) {
  files.forEach((file, index) => {
    doc.addPage();
    let yPosition = 20;

    // File header
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(0, 0, 0);
    doc.text(`File ${index + 1} of ${files.length}`, 20, yPosition);
    yPosition += 10;

    // File path
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(100, 100, 100);
    const filePathLines = doc.splitTextToSize(file.file, pageWidth - 40);
    filePathLines.forEach(line => {
      doc.text(line, 20, yPosition);
      yPosition += 6;
    });
    yPosition += 5;

    // Score with progress bar
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(0, 0, 0);
    doc.text('Quality Score:', 20, yPosition);

    doc.setFontSize(20);
    const scoreColor = getScoreColor(file.score);
    doc.setTextColor(...scoreColor);
    doc.text(String(file.score), 60, yPosition);

    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(100, 100, 100);
    doc.text(`(${getScoreLabel(file.score)})`, 75, yPosition);
    yPosition += 10;

    // Progress bar
    const progressBarWidth = pageWidth - 40;
    const progressBarHeight = 8;

    // Background
    doc.setFillColor(240, 240, 240);
    doc.roundedRect(20, yPosition, progressBarWidth, progressBarHeight, 2, 2, 'F');

    // Progress
    const progressWidth = (file.score / 100) * progressBarWidth;
    doc.setFillColor(...scoreColor);
    doc.roundedRect(20, yPosition, progressWidth, progressBarHeight, 2, 2, 'F');
    yPosition += 20;

    // Issues Section
    if (file.issues && file.issues.length > 0) {
      doc.setFontSize(12);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(239, 68, 68); // Red
      doc.text(`Issues Found (${file.issues.length}):`, 20, yPosition);
      yPosition += 8;

      doc.setFontSize(9);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(60, 60, 60);

      file.issues.forEach((issue, idx) => {
        // Check if we need a new page
        if (yPosition > pageHeight - 40) {
          doc.addPage();
          yPosition = 20;
        }

        // Issue number circle
        doc.setFillColor(239, 68, 68);
        doc.circle(23, yPosition - 1.5, 2, 'F');

        const issueLines = doc.splitTextToSize(issue, pageWidth - 50);
        issueLines.forEach((line, lineIdx) => {
          doc.text(line, 28, yPosition);
          yPosition += 5;
        });
        yPosition += 3;
      });

      yPosition += 5;
    } else {
      doc.setFontSize(12);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(34, 197, 94); // Green
      doc.text('No Issues Found', 20, yPosition);
      yPosition += 15;
    }

    // Recommendations Section
    if (file.recommendations && file.recommendations.length > 0) {
      if (yPosition > pageHeight - 60) {
        doc.addPage();
        yPosition = 20;
      }

      doc.setFontSize(12);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(59, 130, 246); // Blue
      doc.text(`Recommendations (${file.recommendations.length}):`, 20, yPosition);
      yPosition += 8;

      doc.setFontSize(9);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(60, 60, 60);

      file.recommendations.forEach((rec, idx) => {
        // Check if we need a new page
        if (yPosition > pageHeight - 40) {
          doc.addPage();
          yPosition = 20;
        }

        // Recommendation bullet
        doc.setFillColor(59, 130, 246);
        doc.circle(23, yPosition - 1.5, 2, 'F');

        const recLines = doc.splitTextToSize(rec, pageWidth - 50);
        recLines.forEach((line, lineIdx) => {
          doc.text(line, 28, yPosition);
          yPosition += 5;
        });
        yPosition += 3;
      });
    } else {
      doc.setFontSize(12);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(100, 100, 100);
      doc.text('No Recommendations', 20, yPosition);
      yPosition += 15;
    }

    // Separator line at bottom
    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.5);
    doc.line(20, pageHeight - 25, pageWidth - 20, pageHeight - 25);
  });
}

/**
 * Add page numbers to all pages
 */
function addPageNumbers(doc) {
  const pageCount = doc.internal.getNumberOfPages();
  doc.setFontSize(9);
  doc.setTextColor(150, 150, 150);
  doc.setFont('helvetica', 'normal');

  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();

    // Page number
    doc.text(`Page ${i} of ${pageCount}`, pageWidth / 2, pageHeight - 15, { align: 'center' });

    // Footer text
    doc.text('Generated by GitInsights', pageWidth - 20, pageHeight - 15, { align: 'right' });
  }
}

/**
 * Helper: Get color based on score
 */
function getScoreColor(score) {
  if (score >= 80) return [34, 197, 94]; // Green
  if (score >= 60) return [59, 130, 246]; // Blue
  if (score >= 40) return [234, 179, 8]; // Yellow
  return [239, 68, 68]; // Red
}

/**
 * Helper: Get label based on score
 */
function getScoreLabel(score) {
  if (score >= 80) return 'Excellent';
  if (score >= 60) return 'Good';
  if (score >= 40) return 'Fair';
  return 'Poor';
}

/**
 * Helper: Calculate quality distribution
 */
function calculateQualityDistribution(files) {
  return files.reduce(
    (acc, file) => {
      if (file.score >= 80) acc.excellent++;
      else if (file.score >= 60) acc.good++;
      else if (file.score >= 40) acc.fair++;
      else acc.poor++;
      return acc;
    },
    { excellent: 0, good: 0, fair: 0, poor: 0 }
  );
}

/**
 * Helper: Generate key insights
 */
function generateKeyInsights(analysisData, distribution) {
  const insights = [];
  const totalFiles = analysisData.files.length;
  const avgScore = analysisData.summary.overallQuality;

  // Overall quality insight
  if (avgScore >= 80) {
    insights.push('Overall code quality is excellent. The codebase demonstrates strong practices and maintainability.');
  } else if (avgScore >= 60) {
    insights.push('Code quality is good with room for improvement in specific areas identified below.');
  } else if (avgScore >= 40) {
    insights.push('Code quality needs attention. Consider addressing the identified issues to improve maintainability.');
  } else {
    insights.push('Code quality requires immediate attention. Multiple critical issues need to be addressed.');
  }

  // Distribution insight
  if (distribution.excellent > totalFiles * 0.5) {
    insights.push(`${distribution.excellent} out of ${totalFiles} files (${Math.round((distribution.excellent / totalFiles) * 100)}%) have excellent quality scores.`);
  } else if (distribution.poor > totalFiles * 0.3) {
    insights.push(`${distribution.poor} files need significant improvements. Focus on these files first for maximum impact.`);
  }

  // Issue concentration
  const filesWithIssues = analysisData.files.filter(f => f.issues && f.issues.length > 0).length;
  if (filesWithIssues > 0) {
    insights.push(`${filesWithIssues} files contain issues that should be reviewed and addressed.`);
  }

  // Recommendations available
  const filesWithRecommendations = analysisData.files.filter(f => f.recommendations && f.recommendations.length > 0).length;
  if (filesWithRecommendations > 0) {
    insights.push(`AI-powered recommendations are available for ${filesWithRecommendations} files to help improve code quality.`);
  }

  return insights;
}

/**
 * Helper: Extract repository name from URL
 */
function extractRepoName(repoUrl) {
  try {
    const url = new URL(repoUrl);
    const pathParts = url.pathname.split('/').filter(Boolean);
    if (pathParts.length >= 2) {
      return `${pathParts[0]}/${pathParts[1]}`;
    }
    return repoUrl;
  } catch {
    // If not a valid URL, just return as is
    return repoUrl;
  }
}

/**
 * Helper: Sanitize filename
 */
function sanitizeFileName(fileName) {
  return fileName.replace(/[^a-z0-9_-]/gi, '_');
}
