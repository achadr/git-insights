import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

/**
 * Generate a professional PDF report from analysis data
 * @param {Object} analysisData - The analysis data object
 * @param {string} repoUrl - The repository URL
 * @returns {Promise<void>}
 */
export async function generatePDFReport(analysisData, repoUrl) {
  try {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    let yPosition = 20;

    // Extract repo name from URL
    const repoName = extractRepoName(repoUrl);
    const timestamp = new Date(analysisData.summary.timestamp).toLocaleDateString();
    const totalIssues = analysisData.quality?.issueCount || 0;

    // ========== COVER PAGE ==========
    addCoverPage(doc, repoName, analysisData.summary.overallQuality, timestamp, pageWidth, pageHeight);

    // ========== SUMMARY PAGE ==========
    doc.addPage();
    yPosition = 20;
    yPosition = addSummaryPage(doc, analysisData, totalIssues, pageWidth, yPosition);

    // ========== TOP ISSUES & RECOMMENDATIONS PAGE ==========
    doc.addPage();
    yPosition = 20;
    addTopIssuesPage(doc, analysisData, pageWidth, pageHeight, yPosition);

    // ========== FILES OVERVIEW TABLE ==========
    doc.addPage();
    yPosition = 20;
    addFilesOverviewTable(doc, analysisData.files, pageWidth, yPosition);

    // Add page numbers to all pages
    addPageNumbers(doc);

    // Save the PDF
    const fileName = `GitInsights_Report_${sanitizeFileName(repoName)}_${timestamp.replace(/\//g, '-')}.pdf`;
    doc.save(fileName);

    return { success: true, fileName };
  } catch (error) {
    throw new Error(`Failed to generate PDF report: ${error.message}`);
  }
}

/**
 * Add cover page to the PDF
 */
function addCoverPage(doc, repoName, overallQuality, timestamp, pageWidth, pageHeight) {
  // Background color for header
  doc.setFillColor(37, 99, 235); // Blue-600
  doc.rect(0, 0, pageWidth, 80, 'F');

  // GitInsights Logo/Title
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(36);
  doc.setFont('helvetica', 'bold');
  doc.text('GitInsights', pageWidth / 2, 35, { align: 'center' });

  doc.setFontSize(14);
  doc.setFont('helvetica', 'normal');
  doc.text('Code Quality Analysis Report', pageWidth / 2, 50, { align: 'center' });

  // Reset text color
  doc.setTextColor(0, 0, 0);

  // Repository Information
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.text('Repository:', 20, 110);

  doc.setFontSize(16);
  doc.setFont('helvetica', 'normal');
  doc.text(repoName, 20, 125);

  // Analysis Date
  doc.setFontSize(12);
  doc.setTextColor(100, 100, 100);
  doc.text(`Analysis Date: ${timestamp}`, 20, 145);

  // Overall Quality Score - Large Visual
  const scoreColor = getScoreColor(overallQuality);
  const scoreY = 170;

  doc.setFontSize(14);
  doc.setTextColor(0, 0, 0);
  doc.setFont('helvetica', 'bold');
  doc.text('Overall Quality Score', pageWidth / 2, scoreY, { align: 'center' });

  // Score circle background
  doc.setFillColor(...scoreColor);
  doc.circle(pageWidth / 2, scoreY + 35, 30, 'F');

  // Score text
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(48);
  doc.setFont('helvetica', 'bold');
  doc.text(String(overallQuality), pageWidth / 2, scoreY + 42, { align: 'center' });

  // Score label
  doc.setTextColor(0, 0, 0);
  doc.setFontSize(12);
  doc.setFont('helvetica', 'normal');
  doc.text(getScoreLabel(overallQuality), pageWidth / 2, scoreY + 60, { align: 'center' });

  // Footer text
  doc.setFontSize(10);
  doc.setTextColor(150, 150, 150);
  doc.text('Generated by GitInsights - AI-Powered Code Analysis', pageWidth / 2, pageHeight - 20, { align: 'center' });
}

/**
 * Add summary page with statistics
 */
function addSummaryPage(doc, analysisData, totalIssues, pageWidth, startY) {
  let yPosition = startY;

  // Page Title
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text('Analysis Summary', 20, yPosition);
  yPosition += 15;

  // Summary Statistics Cards
  const stats = [
    { label: 'Files Analyzed', value: analysisData.summary.filesAnalyzed, color: [59, 130, 246] },
    { label: 'Total Issues', value: totalIssues, color: [239, 68, 68] },
    { label: 'Quality Score', value: analysisData.summary.overallQuality, color: [147, 51, 234] },
  ];

  const cardWidth = 55;
  const cardHeight = 35;
  const cardSpacing = 10;
  const startX = 20;

  stats.forEach((stat, index) => {
    const x = startX + (cardWidth + cardSpacing) * index;

    // Card background
    doc.setFillColor(...stat.color, 0.1);
    doc.roundedRect(x, yPosition, cardWidth, cardHeight, 3, 3, 'F');

    // Border
    doc.setDrawColor(...stat.color);
    doc.setLineWidth(0.5);
    doc.roundedRect(x, yPosition, cardWidth, cardHeight, 3, 3, 'S');

    // Label
    doc.setFontSize(10);
    doc.setTextColor(100, 100, 100);
    doc.setFont('helvetica', 'normal');
    doc.text(stat.label, x + cardWidth / 2, yPosition + 12, { align: 'center' });

    // Value
    doc.setFontSize(24);
    doc.setTextColor(...stat.color);
    doc.setFont('helvetica', 'bold');
    doc.text(String(stat.value), x + cardWidth / 2, yPosition + 28, { align: 'center' });
  });

  yPosition += cardHeight + 20;

  // Analysis Metadata
  if (analysisData.summary.totalCodeFiles && analysisData.summary.requestedFileLimit) {
    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(100, 100, 100);
    const metadataText = `Analyzed ${analysisData.summary.filesAnalyzed} of ${analysisData.summary.totalCodeFiles} code files (Smart selection prioritized)`;
    doc.text(metadataText, pageWidth / 2, yPosition, { align: 'center' });
    yPosition += 15;
  }

  // Quality Distribution Bar
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text('Quality Distribution', 20, yPosition);
  yPosition += 10;

  // Calculate distribution
  const distribution = calculateQualityDistribution(analysisData.files);
  const barWidth = pageWidth - 40;
  const barHeight = 30;
  const barX = 20;

  // Draw stacked bar
  let currentX = barX;
  const categories = [
    { key: 'excellent', label: 'Excellent (80-100)', color: [34, 197, 94] },
    { key: 'good', label: 'Good (60-79)', color: [59, 130, 246] },
    { key: 'fair', label: 'Fair (40-59)', color: [234, 179, 8] },
    { key: 'poor', label: 'Poor (0-39)', color: [239, 68, 68] },
  ];

  categories.forEach(category => {
    const segmentWidth = (distribution[category.key] / analysisData.files.length) * barWidth;
    if (segmentWidth > 0) {
      doc.setFillColor(...category.color);
      doc.rect(currentX, yPosition, segmentWidth, barHeight, 'F');
      currentX += segmentWidth;
    }
  });

  // Draw border
  doc.setDrawColor(200, 200, 200);
  doc.setLineWidth(1);
  doc.rect(barX, yPosition, barWidth, barHeight, 'S');

  yPosition += barHeight + 15;

  // Legend
  doc.setFontSize(9);
  categories.forEach((category, index) => {
    const legendX = 20 + (index * 45);

    // Color box
    doc.setFillColor(...category.color);
    doc.rect(legendX, yPosition, 4, 4, 'F');

    // Label
    doc.setTextColor(0, 0, 0);
    doc.setFont('helvetica', 'normal');
    doc.text(`${category.label}: ${distribution[category.key]}`, legendX + 6, yPosition + 3);
  });

  yPosition += 15;

  // Key Insights Section
  yPosition += 10;
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('Key Insights', 20, yPosition);
  yPosition += 10;

  const insights = generateKeyInsights(analysisData, distribution);
  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(60, 60, 60);

  insights.forEach(insight => {
    const lines = doc.splitTextToSize(`â€¢ ${insight}`, pageWidth - 50);
    lines.forEach(line => {
      doc.text(line, 25, yPosition);
      yPosition += 6;
    });
    yPosition += 2;
  });

  return yPosition;
}

/**
 * Add files overview table
 */
function addFilesOverviewTable(doc, files, pageWidth, startY) {
  let yPosition = startY;

  // Page Title
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text('Files Overview', 20, yPosition);
  yPosition += 10;

  // Prepare table data
  const tableData = files.map(file => [
    file.file,
    String(file.score),
    getScoreLabel(file.score)
  ]);

  // Generate table
  autoTable(doc, {
    startY: yPosition,
    head: [['File Path', 'Score', 'Rating']],
    body: tableData,
    theme: 'grid',
    headStyles: {
      fillColor: [37, 99, 235],
      textColor: [255, 255, 255],
      fontStyle: 'bold',
      fontSize: 10,
      halign: 'left',
    },
    bodyStyles: {
      fontSize: 8,
      textColor: [0, 0, 0],
      cellPadding: 3,
    },
    columnStyles: {
      0: { cellWidth: 'auto', halign: 'left' },
      1: { cellWidth: 25, halign: 'center', fontStyle: 'bold' },
      2: { cellWidth: 35, halign: 'center' },
    },
    didParseCell: (data) => {
      // Color-code the entire row based on score
      if (data.section === 'body' && data.row.index < tableData.length) {
        const score = parseInt(tableData[data.row.index][1]);
        if (!isNaN(score)) {
          const color = getScoreColor(score);
          // Apply light background to score and rating columns
          if (data.column.index === 1 || data.column.index === 2) {
            data.cell.styles.fillColor = [...color, 25]; // Light opacity
          }
          // Make score text bold with the score color
          if (data.column.index === 1) {
            data.cell.styles.textColor = color;
            data.cell.styles.fontStyle = 'bold';
          }
        }
      }
    },
    margin: { left: 20, right: 20 },
    alternateRowStyles: {
      fillColor: [248, 250, 252], // Very light gray for alternate rows
    },
  });

  return doc.lastAutoTable.finalY + 10;
}

/**
 * Add top issues and recommendations page
 */
function addTopIssuesPage(doc, analysisData, pageWidth, pageHeight, startY) {
  let yPosition = startY;

  // Page Title
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text('Top Issues & Recommendations', 20, yPosition);
  yPosition += 15;

  // ========== TOP ISSUES SECTION ==========
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(239, 68, 68); // Red
  doc.text('Top Issues Found', 20, yPosition);
  yPosition += 8;

  const topIssues = analysisData.quality?.topIssues || [];

  if (topIssues.length > 0) {
    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(60, 60, 60);

    topIssues.forEach((item, index) => {
      // Handle both old format (strings) and new format (objects with file and issue)
      let issueText, filePath;

      if (typeof item === 'string') {
        // Old format - just a string
        issueText = item;
        filePath = null;
      } else {
        // New format - object with file and issue properties
        issueText = item.issue || item;
        filePath = item.file || null;
      }

      // Check if we need more space
      if (yPosition > pageHeight - 40) {
        doc.addPage();
        yPosition = 20;
      }

      // Issue number badge
      doc.setFillColor(239, 68, 68);
      doc.setTextColor(255, 255, 255);
      doc.setFontSize(8);
      doc.circle(23, yPosition - 1.5, 2.5, 'F');
      doc.text(String(index + 1), 23, yPosition, { align: 'center' });

      // Issue text
      doc.setTextColor(60, 60, 60);
      doc.setFontSize(9);
      doc.setFont('helvetica', 'normal');
      const issueLines = doc.splitTextToSize(issueText, pageWidth - 50);
      issueLines.forEach((line) => {
        doc.text(line, 30, yPosition);
        yPosition += 5;
      });

      // File path (if available)
      if (filePath) {
        doc.setTextColor(120, 120, 120); // Gray color
        doc.setFontSize(8);
        doc.setFont('helvetica', 'italic');

        // Truncate file path if too long (keep last 60 characters)
        const displayPath = filePath.length > 60 ? '...' + filePath.slice(-60) : filePath;
        doc.text(`File: ${displayPath}`, 30, yPosition);
        yPosition += 5;
      }

      yPosition += 2;
    });
  } else {
    doc.setFontSize(10);
    doc.setFont('helvetica', 'italic');
    doc.setTextColor(100, 100, 100);
    doc.text('No issues detected', 25, yPosition);
    yPosition += 10;
  }

  yPosition += 10;

  // ========== RECOMMENDATIONS SECTION ==========
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(59, 130, 246); // Blue
  doc.text('General Recommendations', 20, yPosition);
  yPosition += 8;

  const recommendations = generateGeneralRecommendations(analysisData);

  doc.setFontSize(9);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(60, 60, 60);

  recommendations.forEach((rec) => {
    // Check if we need more space
    if (yPosition > pageHeight - 40) {
      doc.addPage();
      yPosition = 20;
    }

    // Recommendation bullet
    doc.setFillColor(59, 130, 246);
    doc.circle(23, yPosition - 1.5, 1.5, 'F');

    // Recommendation text
    const recLines = doc.splitTextToSize(rec, pageWidth - 50);
    recLines.forEach((line) => {
      doc.text(line, 30, yPosition);
      yPosition += 5;
    });
    yPosition += 2;
  });

  // Add a helpful note at the bottom
  yPosition += 10;
  if (yPosition < pageHeight - 50) {
    doc.setFontSize(8);
    doc.setFont('helvetica', 'italic');
    doc.setTextColor(120, 120, 120);
    doc.setFillColor(240, 248, 255); // Light blue background
    doc.roundedRect(20, yPosition, pageWidth - 40, 20, 2, 2, 'F');
    doc.text('Note: These recommendations are generated based on the overall code analysis.', 25, yPosition + 7);
    doc.text('Review the Files Overview section for specific file scores and prioritize accordingly.', 25, yPosition + 14);
  }

  return yPosition;
}

/**
 * Add page numbers to all pages
 */
function addPageNumbers(doc) {
  const pageCount = doc.internal.getNumberOfPages();
  doc.setFontSize(9);
  doc.setTextColor(150, 150, 150);
  doc.setFont('helvetica', 'normal');

  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();

    // Page number
    doc.text(`Page ${i} of ${pageCount}`, pageWidth / 2, pageHeight - 15, { align: 'center' });

    // Footer text
    doc.text('Generated by GitInsights', pageWidth - 20, pageHeight - 15, { align: 'right' });
  }
}

/**
 * Helper: Generate general recommendations based on analysis
 */
function generateGeneralRecommendations(analysisData) {
  const recommendations = [];
  const avgScore = analysisData.summary.overallQuality;
  const issueCount = analysisData.quality?.issueCount || 0;
  const filesAnalyzed = analysisData.summary.filesAnalyzed;

  // Score-based recommendations
  if (avgScore < 60) {
    recommendations.push('Critical: Address high-priority issues immediately to improve code maintainability and reliability.');
    recommendations.push('Focus on refactoring files with scores below 60 as they pose the highest technical debt.');
  } else if (avgScore < 70) {
    recommendations.push('Focus on improving code structure, error handling, and reducing complexity in lower-scoring files.');
    recommendations.push('Consider implementing code review practices to maintain quality standards.');
  } else if (avgScore < 80) {
    recommendations.push('Good overall quality. Focus on standardizing patterns across the codebase for consistency.');
    recommendations.push('Address remaining issues to achieve excellent quality scores across all files.');
  } else {
    recommendations.push('Excellent code quality! Maintain current standards through regular code reviews and testing.');
  }

  // Issue count recommendations
  if (issueCount > 50) {
    recommendations.push(`High issue count detected (${issueCount} total). Prioritize refactoring efforts on files with the most issues.`);
  } else if (issueCount > 20) {
    recommendations.push(`Moderate issue count (${issueCount} total). Create a backlog to systematically address these over time.`);
  }

  // File-specific recommendations
  const lowScoreFiles = analysisData.files.filter(f => f.score < 60);
  if (lowScoreFiles.length > 0) {
    recommendations.push(`${lowScoreFiles.length} file(s) have scores below 60. These should be your top refactoring priority.`);
  }

  // Best practices
  recommendations.push('Implement automated testing to prevent quality regression in the future.');
  recommendations.push('Consider setting up CI/CD quality gates to maintain code quality standards.');

  // Coverage recommendation
  if (analysisData.summary.totalCodeFiles && filesAnalyzed < analysisData.summary.totalCodeFiles) {
    const percentage = Math.round((filesAnalyzed / analysisData.summary.totalCodeFiles) * 100);
    recommendations.push(`This analysis covered ${percentage}% of your codebase. Consider running analysis on remaining files for complete coverage.`);
  }

  return recommendations;
}

/**
 * Helper: Get color based on score
 */
function getScoreColor(score) {
  if (score >= 80) return [34, 197, 94]; // Green
  if (score >= 60) return [59, 130, 246]; // Blue
  if (score >= 40) return [234, 179, 8]; // Yellow
  return [239, 68, 68]; // Red
}

/**
 * Helper: Get label based on score
 */
function getScoreLabel(score) {
  if (score >= 80) return 'Excellent';
  if (score >= 60) return 'Good';
  if (score >= 40) return 'Fair';
  return 'Poor';
}

/**
 * Helper: Calculate quality distribution
 */
function calculateQualityDistribution(files) {
  return files.reduce(
    (acc, file) => {
      if (file.score >= 80) acc.excellent++;
      else if (file.score >= 60) acc.good++;
      else if (file.score >= 40) acc.fair++;
      else acc.poor++;
      return acc;
    },
    { excellent: 0, good: 0, fair: 0, poor: 0 }
  );
}

/**
 * Helper: Generate key insights
 */
function generateKeyInsights(analysisData, distribution) {
  const insights = [];
  const totalFiles = analysisData.files.length;
  const avgScore = analysisData.summary.overallQuality;

  // Overall quality insight
  if (avgScore >= 80) {
    insights.push('Overall code quality is excellent. The codebase demonstrates strong practices and maintainability.');
  } else if (avgScore >= 60) {
    insights.push('Code quality is good with room for improvement in specific areas identified below.');
  } else if (avgScore >= 40) {
    insights.push('Code quality needs attention. Consider addressing the identified issues to improve maintainability.');
  } else {
    insights.push('Code quality requires immediate attention. Multiple critical issues need to be addressed.');
  }

  // Distribution insight
  if (distribution.excellent > totalFiles * 0.5) {
    insights.push(`${distribution.excellent} out of ${totalFiles} files (${Math.round((distribution.excellent / totalFiles) * 100)}%) have excellent quality scores.`);
  } else if (distribution.poor > totalFiles * 0.3) {
    insights.push(`${distribution.poor} files need significant improvements. Focus on these files first for maximum impact.`);
  }

  // Issue count insight
  const issueCount = analysisData.quality?.issueCount || 0;
  if (issueCount > 0) {
    insights.push(`${issueCount} total issues detected across the codebase. See Top Issues page for details.`);
  }

  // Coverage insight
  if (analysisData.summary.totalCodeFiles && analysisData.summary.filesAnalyzed < analysisData.summary.totalCodeFiles) {
    const remaining = analysisData.summary.totalCodeFiles - analysisData.summary.filesAnalyzed;
    insights.push(`${remaining} additional code files were not analyzed. This report focuses on the most impactful files.`);
  }

  return insights;
}

/**
 * Helper: Extract repository name from URL
 */
function extractRepoName(repoUrl) {
  try {
    const url = new URL(repoUrl);
    const pathParts = url.pathname.split('/').filter(Boolean);
    if (pathParts.length >= 2) {
      return `${pathParts[0]}/${pathParts[1]}`;
    }
    return repoUrl;
  } catch {
    // If not a valid URL, just return as is
    return repoUrl;
  }
}

/**
 * Helper: Sanitize filename
 */
function sanitizeFileName(fileName) {
  return fileName.replace(/[^a-z0-9_-]/gi, '_');
}
